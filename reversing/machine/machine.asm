0x00 0x91 push 0x11
0x01 0xec push 0x6c
0x02 0xab push 0x2b
0x03 0xc5 push 0x45
0x04 0x8c push 0xc
0x05 0xc0 push 0x40
0x06 0xac push 0x2c
0x07 0xc3 push 0x43
0x08 0x91 push 0x11
0x09 0xd6 push 0x56
0x0a 0xb8 push 0x38
0x0b 0x99 push 0x19
0x0c 0xd5 push 0x55
0x0d 0x99 push 0x19
0x0e 0xf6 push 0x76
0x0f 0xa4 push 0x24
0x10 0xc3 push 0x43
0x11 0xad push 0x2d
0x12 0x8c push 0xc
0x13 0xe0 push 0x60
0x14 0x8c push 0xc
0x15 0xbc push 0x3c
0x16 0xee push 0x6e
0x17 0xa9 push 0x29
0x18 0xc7 push 0x47
0x19 0x8e push 0xe
0x1a 0xe2 push 0x62
0x1b 0xae push 0x2e
0x1c 0xe1 push 0x61
0x1d 0xb3 push 0x33
0x1e 0xe1 push 0x61
0x1f 0xae push 0x2e
0x20 0xf6 push 0x76
0x21 0x8d push 0xd
0x22 0xea push 0x6a
0x23 0x8b push 0xb
0x24 0xe7 push 0x67
0x25 0x81 push 0x1
0x26 0x8b push 0xb
; if stack is empty, exit
0x27 0x18 jse

; Read and jump to 0x37
; i_stack = ()
; i_stack = (0x2b, character)
0x28 0x08 read
0x29 0x8c push 0xc
0x2a 0x11 call

; stack = [a, b]
; a == b ? jmp to 0x26
; stack = [b]
0x2b 0x41 load 0x1
0x2c 0x8a push 0xa
0x2d 0x80 push 0x0
0x2e 0x01 sub
0x2f 0x14 je

; prints '0' and exit - end of the game
0x30 0xb0 push 0x30
0x31 0x81 push 0x1
0x32 0x10 jump
0x33 0xb1 push 0x31
0x34 0x09 write
0x35 0xaf push 0x2f
0x36 0x10 jump     ; jump outside


;
; if you want to jump to a stack byte
;
; char at b
; i_stack = (a, b, c)
; i_stack = (c, a, b, c)
; stack = [a, b, c]
; stack = [c, a, b, c]
; b == 0? jmp 0x61
; char == 0? jmp 0x61
0x37 0x42 load 0x2 ; loads from stack
0x38 0x42 load 0x2 ; loads char
0x39 0x80 push 0x0 
0x3a 0xa5 push 0x25 
0x3b 0x14 je  

;
; duplicate A
;
; i_stack = (c, a, b, c)
; c == 0 ? jmp 0x61
; i_stack = (a, a, b, c)

; stack = [a, b]
; stack = [b, b]
; a == 0 ? jmp 0x61
0x3c 0x42 load 0x2 ; loads char
0x3d 0x21 swap 0x1 ; swaps char with 1
0x3e 0x80 push 0x0 ;
0x3f 0xa0 push 0x20 
0x40 0x14 je       

; i_stack = (a, a, b, c) ; a == c ? jmp 0x61
; i_stack = (0, a, b, c)
; stack = [a, b, c, d]
; stack = [0, b, c, d], a == d ? jmp 0x61
; char == 1 ? jmp 0x61
0x41 0x80 push 0x0
0x42 0x21 swap 0x1
0x43 0x44 load 0x4
0x44 0x9b push 0x1b
0x45 0x14 je


; stack = [a, b, c, d]
; stack = [d/2, c/2, (c%2+d%2)%2, d/2, c/2, b, c, d]
; i_stack = (0, a, b, c)
; i_stack = (c/2, b/2, (c%2+b%2)%2, c/2, b/2, a, b, c)

0x46 0x20 pop
0x47 0x82 push 0x2
; stack = [2, b, c, d]
0x48 0x42 load 0x2 ; load char
0x49 0x02 div		; char/2
; stack = [c%2, c/2, b, c, d]
0x4a 0x82 push 0x2
; stack = [2, c%2, c/2, b, c, d]
0x4b 0x45 load 0x5 ; load the number from the stack
; stack = [d, 2, c%2, c/2, b, c, d]
0x4c 0x02 div      ; 1/2
; stack = [d%2, d/2, c%2, c/2, b, c, d]
0x4d 0x21 swap 0x1
; stack = [d/2, d%2, c%2, c/2, b, c, d]
0x4e 0x22 swap 0x2
; stack = [d%2, c%2, d/2, c/2, b, c, d]
0x4f 0x00 add      ; 1 + char % 2
; stack = [c%2+d%2, d/2, c/2, b, c, d]
0x50 0x82 push 0x2
0x51 0x21 swap 0x1
0x52 0x02 div      ; (1 + char % 2)/2
; stack = [(c%2+d%2)%2, (c%2+d%2)/ 2, d/2, c/2, b, c, d]
0x53 0x21 swap 0x1
0x54 0x20 pop      ; ignore result, use reminder
; stack = [(c%2+d%2)%2, d/2, c/2, b, c, d]
0x55 0x42 load 0x2 ; load char / 2
0x56 0x42 load 0x2 ; load d/2 

; push 0x5b
; jmp 0x37
0x57 0xa4 push 0x24 ; 
0x58 0x80 push 0x0
0x59 0x01 sub
0x5a 0x11 call     ; 

; stack = [a, b, c, d]
0x5b 0x82 push 0x2
0x5c 0x03 mul
; stack = [2*a, b, c, d]
0x5d 0x00 add
0x5e 0x22 swap 0x2
0x5f 0x20 pop
0x60 0x20 pop

; stack = [2*a+b]
; then, use this offset as a return address


; remove 3 and 1 and ret
; pop(3)
0x61 0x23 swap 0x3
0x62 0x20 pop
; pop(1)
0x63 0x21 swap 0x1
0x64 0x20 pop
0x65 0x12 ret
